<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rastrear Pedido</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
    <style>
        #map { height: 500px; width: 100%; }
        body { font-family: Arial, sans-serif; padding: 20px; }
        #info { background: #e3f2fd; padding: 15px; border-radius: 5px; margin-bottom: 10px; }
    </style>
</head>
<body>
    <h1>Rastrear Pedido</h1>
    <div id="info">
        <p id="tempoEntrega">Calculando rota...</p>
        <p id="distancia"></p>
    </div>
    <div id="map"></div>

    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet-rotatedmarker/leaflet.rotatedMarker.js"></script>
    <script src="/socket.io/socket.io.js"></script>
    <script>
        const socket = io();
        const apiKey = '5b3ce3597851110001cf6248461ce4f521b24420bbc67527fa68a8ab';

        const coordenadasDestino = JSON.parse(sessionStorage.getItem('coordenadasDestino'));

        const map = L.map('map').setView([coordenadasDestino.lat, coordenadasDestino.lon], 13);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: 19
        }).addTo(map);

        const destinoIcon = L.icon({
            iconUrl: 'casa.png',
            iconSize: [45, 45],
            iconAnchor: [22, 45],
            popupAnchor: [0, -45]
        });

        L.marker([coordenadasDestino.lat, coordenadasDestino.lon], { icon: destinoIcon })
            .addTo(map)
            .bindPopup('Endere√ßo de Entrega')
            .openPopup();

        const motoristaIcon = L.icon({
            iconUrl: 'wN5QD.png',
            iconSize: [50, 50],
            iconAnchor: [25, 25],
            popupAnchor: [0, -25]
        });

        let coordenadasMotorista = null;
        let marcadorMotorista = null;
        let rota = null;
        let ultimaPosicao = null;
        let ultimaRotaCalculada = null;
        let animacaoAtiva = null;

        // Calcular dist√¢ncia
        function calcularDistancia(lat1, lon1, lat2, lon2) {
            const R = 6371e3;
            const œÜ1 = lat1 * Math.PI / 180;
            const œÜ2 = lat2 * Math.PI / 180;
            const ŒîœÜ = (lat2 - lat1) * Math.PI / 180;
            const ŒîŒª = (lon2 - lon1) * Math.PI / 180;

            const a = Math.sin(ŒîœÜ / 2) * Math.sin(ŒîœÜ / 2) +
                      Math.cos(œÜ1) * Math.cos(œÜ2) *
                      Math.sin(ŒîŒª / 2) * Math.sin(ŒîŒª / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

            return R * c;
        }

        function formatarTempo(tempoMinutos) {
            const horas = Math.floor(tempoMinutos / 60);
            const minutos = Math.round(tempoMinutos % 60);
            if (horas > 0) {
                return `${horas}h ${minutos}min`;
            }
            return `${minutos} min`;
        }

        function calcularAngulo(lat1, lon1, lat2, lon2) {
            const rad = Math.PI / 180;
            const dLon = (lon2 - lon1) * rad;
            const y = Math.sin(dLon) * Math.cos(lat2 * rad);
            const x = Math.cos(lat1 * rad) * Math.sin(lat2 * rad) -
                      Math.sin(lat1 * rad) * Math.cos(lat2 * rad) * Math.cos(dLon);
            let ang = Math.atan2(y, x);
            return (ang * 180 / Math.PI + 360) % 360;
        }

        // Interpola√ß√£o suave entre posi√ß√µes
        function interpolarPosicao(inicio, fim, duracao = 1000) {
            if (animacaoAtiva) clearInterval(animacaoAtiva);

            const passos = 30;
            const intervalo = duracao / passos;
            let passo = 0;

            animacaoAtiva = setInterval(() => {
                passo++;
                const progresso = passo / passos;
                
                const latAtual = inicio.lat + (fim.lat - inicio.lat) * progresso;
                const lonAtual = inicio.lon + (fim.lon - inicio.lon) * progresso;

                if (marcadorMotorista) {
                    marcadorMotorista.setLatLng([latAtual, lonAtual]);
                }

                if (passo >= passos) {
                    clearInterval(animacaoAtiva);
                    animacaoAtiva = null;
                }
            }, intervalo);
        }

        // Calcular rota com throttling
        async function calcularRotaETempo(latInicio, lonInicio, latFim, lonFim) {
            // S√≥ recalcular se moveu mais de 50 metros
            if (ultimaRotaCalculada) {
                const distancia = calcularDistancia(
                    ultimaRotaCalculada.lat, 
                    ultimaRotaCalculada.lon,
                    latInicio, 
                    lonInicio
                );
                if (distancia < 50) return; // N√£o recalcular
            }

            try {
                const url = `https://api.openrouteservice.org/v2/directions/driving-car?api_key=${apiKey}&start=${lonInicio},${latInicio}&end=${lonFim},${latFim}`;
                const response = await fetch(url);
                const data = await response.json();

                const coordenadasRota = data.features[0].geometry.coordinates.map(coord => [coord[1], coord[0]]);
                const duracaoMinutos = data.features[0].properties.segments[0].duration / 60;
                const distanciaKm = (data.features[0].properties.segments[0].distance / 1000).toFixed(1);

                document.getElementById('tempoEntrega').innerText = 
                    `‚è±Ô∏è Tempo estimado: ${formatarTempo(duracaoMinutos)}`;
                document.getElementById('distancia').innerText = 
                    `üìç Dist√¢ncia: ${distanciaKm} km`;

                if (rota) {
                    rota.setLatLngs(coordenadasRota);
                } else {
                    rota = L.polyline(coordenadasRota, { 
                        color: '#2196F3', 
                        weight: 5, 
                        opacity: 0.7 
                    }).addTo(map);
                }

                ultimaRotaCalculada = { lat: latInicio, lon: lonInicio };

            } catch (error) {
                console.error('Erro ao calcular rota:', error);
            }
        }

        // Atualizar localiza√ß√£o do motorista
        socket.on('atualizacaoLocalizacao', (data) => {
            const novaPosicao = { lat: data.lat, lon: data.lon };

            if (marcadorMotorista) {
                // Interpolar movimento suave
                const posicaoAtual = marcadorMotorista.getLatLng();
                interpolarPosicao(
                    { lat: posicaoAtual.lat, lon: posicaoAtual.lng },
                    novaPosicao,
                    1500
                );

                // Calcular rota√ß√£o
                if (ultimaPosicao) {
                    const angulo = calcularAngulo(
                        ultimaPosicao.lat, ultimaPosicao.lon,
                        novaPosicao.lat, novaPosicao.lon
                    );
                    marcadorMotorista.setRotationAngle(angulo);
                }
            } else {
                marcadorMotorista = L.marker(
                    [novaPosicao.lat, novaPosicao.lon],
                    { icon: motoristaIcon, rotationAngle: 0, rotationOrigin: "center" }
                ).addTo(map)
                .bindPopup('Motorista')
                .openPopup();
            }

            ultimaPosicao = { ...novaPosicao };
            coordenadasMotorista = novaPosicao;

            // Recalcular rota (com throttling interno)
            calcularRotaETempo(
                novaPosicao.lat, 
                novaPosicao.lon, 
                coordenadasDestino.lat, 
                coordenadasDestino.lon
            );
        });
    </script>
</body>
</html>
